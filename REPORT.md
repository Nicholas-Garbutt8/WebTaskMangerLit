COMP2110 - Project Task 3
Deployment Details:
The webpage can be accessed at: [https://22262419.comp2110-group8.pages.dev/](url)


The webpage is being hosted using a free Cloudflare account. To start, an account had to be created and then used to install the wrangler package inside of a command prompt. Next, npx wrangler was run to login into the account inside of the command prompt which also required a verification of the email. Next, the project was created and named “COMP2110-group8”. Then, the command prompt was set to the directory to the web page's location. This was done using “cd” cd /d to change the directory to ("D:\GitHub Rep\web-development-project-group-8"), as the location needed to be switched to the location of the drive it was using. Now the pages were ready to publish and upon selecting the project, the website URL was provided.  If the webpage needs to be updated you can update the page by publishing the webpage again using the same account and ‘npx wrangler pages deploy .’ while the current directory is set to the webpage folder. 
What was Achieved:

The overall website CSS was taken from one member’s “Web Development Project - Part 1” as this was unanimously decided to be a good implementation choice of CSS. The overall CSS changed the websites’ colours to fit a specific palette and the overall padding of widgets and task cards. This also altered the overall font and text sizes of the task cards. Additionally, smaller changes to the website include the curved corners of the tasks in the task cards and hovering over different elements of the page to slightly alter colours.
The timer widget was implemented into the second slot of the widget container. For this timer, the basic requirements were met by making it count down from 15 minutes to 0. Some extra complexity to the timer was added to make it more functional and serve as a tool that could be used. The first added function was the ability to start, stop or pause the timer. This was done using buttons at the bottom of the widget box. The next function that was added was the ability to reset the timer. This allowed the timer to be reused after it had been completed. Then the ability to set the timer was added. This was done to allow for the timer to be dynamic and not always be on a specific set time. Sound for the timer was also implemented as well as a change of text when it is completed to make it apparent when the timer is done.
The upcoming tasks widget was developed and implemented into the first slot of the widget container. The entire purpose of the upcoming task widget is to display the tasks in the “ToDo” section of the website in a more condensed manner to only display the key information such as the task name and task’s due date. This makes it so this widget can be used for its vital information rather than having to look at the “ToDo” task card specifically. This widget contains the means to load data from the tasks so it can be rendered out with HTML return statements. In addition to just getting the data to display the upcoming tasks, the card also displays a date field that updates the date displayed to the current date so users can know when a task is due from the current date. 
The game widget was developed and then implemented to fit into the last slot of the widgets category on the page, the main purpose the game widget was met, as seen on the website itself, its main intention was to provide the user with the ability to import a number that would be used as a range to generate a set of numbers starting from 0, all the way to the desired number range that was entered. Then the user is given 3 attempts to guess the randomly generated number from the desired number range. It contains logic similar to one of the pre-existing widgets already included within the package we received, the BMI calculator widget. After taking a look at the code and taking inspiration from certain features, by implementing a similar method using form submissions, the functionality and the design of the “game-widget” were achieved. Originally, the CSS that the widget had started with didn’t match the overall design of the website, after a bit of tweaking to the overall design, the design of the game-widget turned out to be what it is now. The added flair to the hovering of the buttons was added to remain consistent with the overall page design. 
Functionality around task cards has been extended through the implementation of features recommended via the iLearn Web Development Project Part 2 information page: the layout and display of task cards have been enhanced with hover effects added to points of interaction for visual feedback, and responsive styling that allows the website to maintain a usable state throughout a variety of viewport widths. The task-edit form dialogue “<edit-task>” has been improved to match the visual standards of the rest of the site in addition to the component button itself, it has also been expanded with a new option to change the category of a task such as that tasks can be placed in different task boards. The implementation of edit-task has been studied to produce new components: “create-task.js”, “delete-task.js”, and “detailed-view.js” each implementing task creation, deletion and a pop-up view for tasks with long headers or descriptions respectively. 
The create-task component itself is a button with a “+” symbol that can be seen on each task-board at the top of the boards’ tasks section. Upon interacting with it, a dialogue appears with a form that borrows its layout from edit-task. The user can then input their desired new task information to create the task. Upon this, the create-task component will submit a “POST” request to the server through a new ‘createTask()’ method inside of models.js based on updateTask(). But instead of accepting an id it only accepts a newTask object from which the server having no id to associate the information with makes a new task. The delete-task component renders a button that can be seen near the bottom of each existing task. Interacting with this button sends a delete request to the server through a new ‘deleteTask()’ method inside models.js. This method is modelled after “updateTask” and accepts a task id to let the server know which task should be deleted.




Updating, deleting and creating tasks will throw user events for edit-task, create-task, detailed-view, and task-card components to update via the _loadData() method through their event listeners defined in their constructors. Detailed-view is a new component that is only rendered on task cards if their content: header or description is deemed too long via a new method: “shortenText()” which truncates the summary or text of a task card and adds an ellipsis. If this “shortenText” method has cut either the summary or text of a task card, it will return an object with a true value boolean. This is used in render() to determine whether to render the task normally or with shortened content and the new detailed view component. The detailed view itself renders a button with a four arrow symbol to represent expansion, which upon interacting displays a dialogue with a larger view of the task and all of the content, it also features an edit-task component inside if the user wishes to alter the content from that state of the website.

What was Challenging:
Communication towards the beginning of the project was the most difficult throughout the entire project length as members were still deciding which widget to create and were not having too much success when it came to creating these widgets. However, as an issue, this was minor as over time our understanding of what we wanted to do and how to do it grew most likely due to individual research on specific aspects of our respective widgets. Towards the final few weeks of the project being due communication was better as we had all been performing tasks separately in contribution to the overall project but had not yet combined our work. Upon combining work and implementing all widgets into the webpage our nerves had eased as we saw a successfully operational website through our combined work. The final changes were small CSS aspects, to make the website uniform and consistent. This proved to be quite simple and easy to perform. 
A main source of difficulty came from trying to understand the given code and how it worked together to create the default displayed page we were to improve. This also greatly meant that our understanding of Lit Elements needed to be sound to make sure we could effectively alter the given code and implement our new code. Specifically, the upcoming widget relied on the data from the “TaskModel” and the only means of the given website using this data was through several pre-build javascript files each with differing Lit Elements. This made it quite complicated to try and understand how that system worked specifically as generating the task cards was one of the more complex aspects of the given webpage. The game widget and timer widget relied on properties defined within their files and didn’t have to mess around with the “TaskModel” data. These widgets were still difficult to construct as they relied heavily on individual understanding of how to use these properties to get the desired results. The pre-build “BMI widget” provided insights into the usage of buttons and how these buttons could be used to manipulate aspects of the respective widgets. 



What was Rewarding:
Since this was some of the group member’s first time using Lit, at first it was hard to come to an understanding of the general functionality of the elements that Lit provides, thanks to the lectures, practicals and overall practice that the requirements of widget-creation had provided, the overall learning ceiling that was previously present had been broken, hence the development of the existing widget-components that are in use on the website now. It helped to see and learn how the other group members had taken the approach to learning and implementing their own Lit Elements to the page, going over each other’s code allowed for the improvement to our ease of understanding the overall functionality and purpose of the Lit Elements, and how to implement them into our website. On top of this, the pre-existing widgets included in the file we had received also provided a means of helping us understand the usage and implementation of Lit Elements on the website. Without these pre-existing elements to guide us through the implementation of our widgets, I’m sure we would’ve had a harder time properly understanding the functionality of Lit Elements, ultimately affecting the means of creating our widgets used on the page. Overall, all these features allowed us to understand Lit Elements more proficiently.
The next thing that we felt contributed to improving our understanding of the content and our web technology skills is that Git was used to allow for collaboration between the four group members and version control. This bettered our understanding of the unit as it highlighted a key skill of how to manage using Github and how we can communicate with our commit messages, code style, consistency and how to properly pull and push to resolve any conflicts that arose when developing the web application. Understanding when to commit code and having detailed commits taught us version control to ensure we always had a working version of our code. This ensured that we always had a version to fall back on and allowed us to understand the changes made. It also taught us how to maintain the style of our code through, mainly the CSS design, to ensure all widgets had similar or the same colour scheme. It also taught us an important part of this unit: sharing code and distributing work. This included push, pull and how to resolve conflicts this was done by communicating what parts we were working on and when we were going to push it also made us aware of always using the most up-to-date version.







Individual Reflection:
Noah (47878657):
For Task 2 I chose not to implement a widget but instead be solely responsible for the functionality and styling surrounding the main task cards and task boards. I chose these responsibilities because I was most interested in interacting with server requests and response handling. In addition, as the team decided on implementing my design, having myself be responsible for the main task management area simplified the style implementation process as it prevented me from having to potentially interfere with the set styling of another person if I was instead responsible for a widget but also responsible for style implementation. As for difficulties encountered during task card functionality implementation and improvements, problems around component creation were minimal with much of the time being invested in understanding the already-established “edit-task.js” component and  “update task()” method inside of models.js to create new components and methods needed for added task functionality such as task creation and deletion. Much of the project's difficulty was concentrated on integrating the new components into the design in a way such that it did not conflict with the defined structures and blended nicely with the rest of the website's appearance.

Matthew (47865377): 
In complete honesty, I had no clear goal on the intent of the widget I would be coding for Originally I had wanted to go for something easy and that would take us the least amount of time, allowing me to lay back for a bit. Ultimately, no widgets that I had taken a look at interested me. I decided to try the “game-widget”, fully knowing the difficulty that I could experience while implementing it. At first, I had the idea of creating a tic-tac-toe game to represent the “game-widget”, however, when coming to coding the idea, my mind would constantly wander away from the topic, also important to know, when coming to researching the idea, I could not find any useful links that I could reference and learn off. I didn’t have a clear goal in mind until I had the idea of creating a game where a player could guess a random number came to mind. It was a perfect idea, as it was something I had experience in creating, and it also served the benefit of being easy and lightweight to create, requiring not much time to implement. At first, I found it challenging to implement the forms required for the inputs of the game but after taking inspiration from the pre-existing “BMI calculator widget”, I had learnt how to properly implement the forms required. Overall, coding and implementing the “game widget” wasn't that difficult. 







Nicholas (47802561): 
I picked to create a timer for the widget. This widget was chosen because it is a useful tool that I would use when working on projects and I had thought of some ways to add extra complexity to it. The main difficulty I had was finding all the functions that would be needed to make a timer and then I found how to make the timer operational, including how to find user input through prompts and what would happen if it is invalid. This resulted in NaN which I found was acceptable for an incorrect input. Then finding all the parts that need to change when each function is called also took a bit. This created some difficulties as I needed to find all the cases when the code would break when a function was called and set the value of other parts. For example originally when I had the timer reset it would just reset to the current timer instead of the start time.

Avi (47802596):
I created an iteration of the weekly summary widget that showed all upcoming tasks as displayed by the “ToDo” task card. However, to not simply repeat the same information in a different section of the webpage, I chose to only display the important elements of what the “ToDo” section already contained. With this in mind, the displayed aspects were the names of the tasks and the due dates of the tasks. This led to a well-structured widget being developed that did not contain too much information. The main difficulties came down to trying to understand Lit elements as this had only been tackled for one or two weeks in the practicals. The importing aspects were also a bit sketchy to begin with as well as trying to remember basic functions and rendering HTML to go back to the website. However, spending time looking at the project files provided and understanding how these javascript files interacted with the website, provided a better understanding of Lit elements and the functions within. 
